# Technical Overview

1. [Tech Stack](#tech-stack)
2. [Node Roles](#node-roles)
3. [Runtime Storage](#runtime-storage)
4. [Extrinsics](#extrinsics)
5. [RPC](#rpc)

## Tech Stack
### IPFS
Our integration with rust-ipfs (embedded within the substrate runtime) is based on [prior work](https://rs-ipfs.github.io/offchain-ipfs-manual/introduction.html). The iridium-labs/substrate [offchain_ipfs_v3](https://github.com/iridium-labs/substrate/tree/offchain_ipfs_v3) branch maintained in sync with the latest substrate master. 

The ui we provide relies on a local IPFS instance to add data (iris does not). To add data through the UI you must first run an instance of IPFS locally (you don't need to run an IPFS if you want read only access).

### Substrate
Substrate is a blockchain framework built by parity. It provides the building blocks for creating a blockchain, including the database, consensus, rpc, and much more. 

Iris is a Proof of Authority blockchain. Since the OCW currently must send signed transactions, only validator nodes can publish results on chain (for the moment).

Pallets
- assets 
- balances
- iris
- contracts


### React
We use react to build the user interface to interact with our node. We specifically rely on the `polkadotjs` and `ipfs-http-core` libraries.

## Node Roles
- **Storage Provider**: The storage provider node's responsibility includes processing commands added to the queue by other nodes and submitting the results of the command on chain. 
- **Content Owner**: A content owner is responsible for making data available in some external IPFS node and interacting with Iris to ingest and maintain access to it.
- **Content Consumer**: A content consumer is responsible for using owned tickets to access owned content.

## Runtime Storage
---
* DataQueue
* Stores a vector of DataCommand enums, which are processed by iris nodes to interact with IPFS.
```
StorageValue<
      _,
      Vec<DataCommand<<T::Lookup as StaticLookup>::Source, T::AssetId, T::Balance, T::AccountId>>,
      ValueQuery
  >
```
---

 * AssetClassOwnership
 * Maps owner to cid to asset id
  ```
    StorageDoubleMap<
        _,
        Blake2_128Concat,
        T::AccountId,
        Blake2_128Concat,
        Vec<u8>,
        T::AssetId,
        ValueQuery,
    >
  ```  

---  
* AssetAccess
* Maps an accountId to a Cid they have access to, to the account id of the owner of the underlying asset class
  ```
   StorageDoubleMap<
        _,
        Blake2_128Concat,
        T::AccountId,
        Blake2_128Concat,
        Vec<u8>,
        T::AccountId,
        ValueQuery,
    >
  ```

## Extrinsics

### Iris Pallet
--- 
- `create_storage_asset`
- description: submits an on-chain request to fetch data and add it to iris 
- weight: `0`
- parameters:
  * `admin`: The address of the node who the asset administration is assigned
  * `addr`: the multiaddress where the data exists
       example: `/ip4/192.168.1.170/tcp/4001/p2p/12D3KooWMvyvKxYcy9mjbFbXcogFSCvENzQ62ogRxHKZaksFCkAp`
  * `cid`: the cid to fetch from the multiaddress
       example: `QmPZv7P8nQUSh2CpqTvUeYemFyjvMjgWEs8H1Tm8b3zAm9`
  * `id`: the unique id of the asset class -> should be generated instead
  * `balance`: the balance to back the asset class which will be created
---
* `request_data`
* description: Queue a request to retrieve data behind some owned CID from the IPFS network
* weight: `0`
* parameters
  * `owner`: The owner node
  * `cid`: the cid to which you are requesting access
---
* `submit_ipfs_results`
  * Description: submits IPFS results on chain and creates new ticket config in runtime storage
  * Parameters:
    * `admin`: The admin account
    * `cid`: The cid generated by the OCW
    * `id`: The AssetId (passed through from the create_storage_asset call)
    * `balance`: The balance (passed through from the create_storage_asset call)
---
* `mint_tickets`
* Description: Only callable by the owner of the asset class. Mint a static number of assets (tickets) for some asset class (cid).
 * weight: `0`
 * Parameters:
   * origin: should be the owner of the asset class
   * beneficiary: the address to which the newly minted assets are assigned
   * cid: a cid owned by the origin, for which an asset class exists
   * amount: the number of tickets to mint
---
* `purchase_ticket`
  * Description: Not yet implemented
---

## RPC 

### Data Ejection 
- `iris_retrieveBytes`
- Description: This RPC endpoint allows external origins to access data that exists in Iris, to which they have been granted access. 
- Parameters:
  - message: a signed messaged
  - accountId: the account id of the address requesting the data. Should be the same account that signed the message
  - block_number: needed? could possibly use this instead of accountid.

